// helper: compute outward-facing normalized normal for triangle (p1,p2,p3)
vec3 faceNormal(vec3 p1, vec3 p2, vec3 p3, vec3 cen) {
    vec3 n = normalize(cross(p2 - p1, p3 - p1));
    // if normal points toward centroid, flip it so it points outward
    if (dot(n, cen - p1) > 0.0) n = -n;
    return n;
}

// signed-distance for a convex tetrahedron using plane distances
float sdTetrahedron(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d) {
    // centroid for consistent normal orientation
    vec3 cent = (a + b + c + d) * 0.25;

    vec3 n1 = faceNormal(a, b, c, cent); // face abc
    vec3 n2 = faceNormal(a, c, d, cent); // face acd
    vec3 n3 = faceNormal(a, d, b, cent); // face adb
    vec3 n4 = faceNormal(b, d, c, cent); // face bdc  (same as b,c,d but ordering chosen)

    float d1 = dot(p - a, n1);
    float d2 = dot(p - a, n2);
    float d3 = dot(p - a, n3);
    float d4 = dot(p - b, n4);

    // for convex polyhedron the signed distance can be approximated as max of face distances
    return max(max(max(d1, d2), d3), d4);
}

// --------- Scene SDF (rotation applied) ---------
float mapScene(vec3 p)
{
    // rotate hex-cone (same rotation you use elsewhere)
    float t = iTime * 0.7;
    float cs = cos(t), sn = sin(t);
    p.xz = mat2(cs, -sn, sn, cs) * p.xz;
    
    // Example tetra vertices (not degenerate)
    vec3 a = vec3( 0.0,  0.8,  0.0);
    vec3 b = vec3( 0.7, -0.2,  0.4);
    vec3 c = vec3(-0.6, -0.2,  0.5);
    vec3 d = vec3( 0.0, -0.2, -0.7);
    
    return sdTetrahedron(p, a, b, c, d);
}



// -------- Lighting --------
vec3 getNormal(vec3 p)
{
    const float e = 0.001;
    return normalize(vec3(
        mapScene(p + vec3(e,0,0)) - mapScene(p - vec3(e,0,0)),
        mapScene(p + vec3(0,e,0)) - mapScene(p - vec3(0,e,0)),
        mapScene(p + vec3(0,0,e)) - mapScene(p - vec3(0,0,e))
    ));
}

// -------- Raymarch --------
float raymarch(vec3 ro, vec3 rd)
{
    float t = 0.0;
    for(int i=0;i<120;i++)
    {
        vec3 p = ro + rd * t;
        float d = mapScene(p);
        if(d < 0.001) return t;
        t += max(d,0.001);
        if(t > 20.0) break;
    }
    return -1.0;
}


// -------- Main --------
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    
    // Camera setup
    vec3 ro = vec3(0.0, 0.9, 4.0);
    vec3 lookAt = vec3(0.0, -0.6, 0.0);
    vec3 forward = normalize(lookAt - ro);
    vec3 right = normalize(cross(vec3(0.0,1.0,0.0), forward));
    vec3 up = cross(forward, right);
    vec3 rd = normalize(uv.x*right + uv.y*up + 1.0*forward);

    float tHit=raymarch(ro,rd);
    float t = iTime * 0.7;
    float cs = cos(t), sn = sin(t);
    

    if(tHit > 0.0)
    {
        vec3 lightPos = vec3(2.0, 3.0, 2.0);
        vec3 p = ro + rd * tHit;
        vec3 n = getNormal(p);
        vec3 l = normalize(lightPos - p);

        //ambient
        vec3 ambient = vec3(0.1,0.18,0.3);
        
        //diffuse
        vec3 layer1 = vec3(0.4, 0.7, 1.0);
        vec3 layer2 = vec3(0.3, 0.5, 0.8);
        vec3 layer3 = vec3(0.2, 0.4, 0.6);
        vec3 layer4 = vec3(0.1, 0.3, 0.5);
        vec3 layer5 = vec3(0.0, 0.2, 0.4);
        
        
        
        float diff=max(dot(n,l),0.0);
        vec3 diffuseColor = layer1 * diff * 0.2
                  + layer2 * diff * 0.2
                  + layer3 * diff * 0.2
                  + layer4 * diff * 0.2
                  + layer5 * diff * 0.2;
        vec3 diffuse=diffuseColor*diff*2.0;
        
        
        //specular
        float specMultiplier = pow(max(dot(reflect(-l,n),-rd),0.0),64.0)*1.5;
        vec3 specColor=vec3(1.0)*specMultiplier;
        
      
        vec3 col = ambient + diffuse  + specColor;
        fragColor = vec4(col, 1.0);

    }
    else
    {
        fragColor = vec4(0.02, 0.02, 0.03, 1.0);
    }
}
